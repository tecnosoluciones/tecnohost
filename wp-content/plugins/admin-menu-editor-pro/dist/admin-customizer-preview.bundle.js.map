{"version":3,"file":"admin-customizer-preview.bundle.js","mappings":"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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,IAAI,MAAM,IAAI,KAAK,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW,KAAK,SAAS,KAAK,KAAK,KAAK,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS,IAAI,MAAM,EAAE,MAAM;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,kCAAkC;AACxF,SAAS;AACT;AACA;AACA;AACA,sDAAsD,iCAAiC;AACvF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB,EAAE,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wCAAwC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wEAAwE;AAC7E,CAAC,8CAA8C;AAC/C","sources":["webpack:///./extras/modules/admin-customizer/preview-handler.ts","webpack:///./extras/modules/admin-customizer/admin-customizer-base.js","webpack:///./extras/style-generator/style-generator.js"],"sourcesContent":["'use strict';\n\nimport {AmeCustomizable} from '../../pro-customizables/assets/customizable.js';\nimport {AmeAdminCustomizerBase} from './admin-customizer-base.js';\nimport {AmeStyleGenerator} from '../../style-generator/style-generator.js';\n\ndeclare var wsAmeAcPreviewData: AmeAdminCustomizerPreview.PreviewScriptData;\n\n//Compatibility note: This script is not compatible with IE11 because it uses some\n//modern JS features like the URLSearchParams class.\n\nnamespace AmeAdminCustomizerPreview {\n\timport ThrottledPreviewRegistry = AmeCustomizable.ThrottledPreviewRegistry;\n\tconst $ = jQuery;\n\n\texport interface PreviewScriptData extends AmeAdminCustomizerBase.ScriptData {\n\t\tstylePreviewConfigs?: AmeStyleGenerator.Preview.StyleGeneratorPreviewConfig[];\n\t}\n\n\texport class PreviewHandler extends AmeAdminCustomizerBase.AdminCustomizerBase {\n\t\tprivate readonly changesetName: string;\n\t\tprivate readonly connection: ReturnType<typeof AmeAcCommunicator.connectToParent>;\n\n\t\tprivate readonly previewRegistry: ThrottledPreviewRegistry;\n\t\tprivate readonly currentPreviewValues: Record<string, any> = {};\n\n\t\tconstructor(scriptData: PreviewScriptData) {\n\t\t\tsuper(scriptData);\n\t\t\tthis.changesetName = scriptData.changesetName;\n\n\t\t\tthis.previewRegistry = new ThrottledPreviewRegistry(\n\t\t\t\t(settingId: string, defaultResult: any) => {\n\t\t\t\t\tif (this.currentPreviewValues.hasOwnProperty(settingId)) {\n\t\t\t\t\t\treturn this.currentPreviewValues[settingId];\n\t\t\t\t\t}\n\t\t\t\t\t//Try the script data. It should have the current value from the changeset.\n\t\t\t\t\tif (\n\t\t\t\t\t\tscriptData.settings.hasOwnProperty(settingId)\n\t\t\t\t\t\t&& scriptData.settings[settingId].hasOwnProperty('value')\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn scriptData.settings[settingId].value;\n\t\t\t\t\t}\n\t\t\t\t\treturn defaultResult;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis.connection = AmeAcCommunicator.connectToParent(\n\t\t\t\t{\n\t\t\t\t\t'previewSetting': (settingId: string, value: any) => {\n\t\t\t\t\t\tthis.currentPreviewValues[settingId] = value;\n\n\t\t\t\t\t\tif (!this.previewRegistry.canPreview(settingId)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.previewRegistry.queuePreview(settingId);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\t'getCurrentUrl': () => {\n\t\t\t\t\t\treturn window.location.href;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tscriptData.allowedCommOrigins,\n\t\t\t\tscriptData.isWpDebugEnabled\n\t\t\t);\n\n\t\t\tthis.connection.promise.then((c) => {\n\t\t\t\tif (typeof c === 'undefined') {\n\t\t\t\t\tif (console && console.warn) {\n\t\t\t\t\t\tconsole.warn('Connection succeeded, but the communicator is undefined. This should be impossible.');\n\t\t\t\t\t}\n\t\t\t\t\treturn; //This should never happen.\n\t\t\t\t}\n\n\t\t\t\t//Let the parent know the current URL. The parent might not be able to\n\t\t\t\t//read it due to cross-domain restrictions, and if there are any redirects,\n\t\t\t\t//the actual URL might not match the frame src that was set by the parent.\n\t\t\t\tc.execute('notifyPreviewUrlChanged', window.location.href);\n\t\t\t});\n\n\t\t\t$(() => {\n\t\t\t\tthis.addPreviewParamsToLinks();\n\n\t\t\t\t//Handle clicks on links.\n\t\t\t\t$(document.body).on('click.ame-ac-preview', 'a', (event) => {\n\t\t\t\t\treturn this.handleLinkClick(event);\n\t\t\t\t});\n\n\t\t\t\t//Block form submissions. Theme Customizer supports those, but we don't\n\t\t\t\t//(at least for now).\n\t\t\t\t$(document.body).on('submit.ame-ac-preview', 'form', function (event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t//For convenience, support for StyleGenerator previews is built-in.\n\t\t\tfor (const previewConfig of (scriptData.stylePreviewConfigs || [])) {\n\t\t\t\tconst previewInstance = new AmeStyleGenerator.Preview.StyleGeneratorPreview(previewConfig);\n\t\t\t\tthis.previewRegistry.registerPreviewUpdater(\n\t\t\t\t\tpreviewInstance.getPreviewableSettingIDs(),\n\t\t\t\t\tpreviewInstance\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Add preview-specific query parameters to all links.\n\t\t */\n\t\taddPreviewParamsToLinks() {\n\t\t\tconst self = this;\n\t\t\t$('a[href]').each(function (this: HTMLElement) {\n\t\t\t\tconst element = this;\n\t\t\t\tif (!(element instanceof HTMLAnchorElement)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst $link = $(this);\n\n\t\t\t\t//Don't modify internal anchors like \"#abc\".\n\t\t\t\tif (self.isInternalAnchor($link)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Flag and skip non-previewable links.\n\t\t\t\tif (!self.isPreviewableLink(element)) {\n\t\t\t\t\t$link.addClass('ame-ac-not-previewable');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Add the preview query parameter(s).\n\t\t\t\tconst params = new URLSearchParams(element.search);\n\t\t\t\tparams.set('ame-ac-preview', '1');\n\t\t\t\tparams.set('ame-ac-changeset', self.changesetName);\n\t\t\t\telement.search = '?' + params.toString();\n\t\t\t});\n\t\t}\n\n\t\tisPreviewableLink(element: HTMLAnchorElement): boolean {\n\t\t\treturn this.isPreviewableUrl(element);\n\t\t}\n\n\t\tisInternalAnchor($link: JQuery): boolean {\n\t\t\tconst href = $link.attr('href');\n\t\t\tif (typeof href === 'undefined') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (href.substring(0, 1) === '#');\n\t\t}\n\n\t\thandleLinkClick(event: JQueryEventObject) {\n\t\t\tconst $link = $(event.target).closest('a');\n\n\t\t\t//Let anchors work as normal.\n\t\t\tif (this.isInternalAnchor($link)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Prevent the browser from navigating to non-previewable links.\n\t\t\tconst anchorElement = $link.get(0) as HTMLAnchorElement;\n\t\t\tif (!this.isPreviewableLink(anchorElement)) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Tell the parent (i.e. the admin customizer) to load the link.\n\t\t\tif (this.connection.isConnected) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.connection.execute('setPreviewUrl', anchorElement.href);\n\t\t\t}\n\t\t}\n\n\t\t// noinspection JSUnusedGlobalSymbols Used in other modules.\n\t\tregisterPreviewer(settingId: string, callback: (newValue: any) => void) {\n\t\t\tthis.previewRegistry.registerPreviewCallback(settingId, callback);\n\t\t}\n\n\t\t// noinspection JSUnusedGlobalSymbols Also used in other modules.\n\t\tregisterPreviewUpdater(settingIds: string[], updater: AmeCustomizable.PreviewUpdater) {\n\t\t\tthis.previewRegistry.registerPreviewUpdater(settingIds, updater);\n\t\t}\n\n\t\t// noinspection JSUnusedGlobalSymbols\n\t\tregisterRpcMethod(methodName: string, handler: (...args: any) => any) {\n\t\t\tthis.connection.addRpcMethod(methodName, handler);\n\t\t}\n\t}\n\n\tconst previewHandler = new PreviewHandler(wsAmeAcPreviewData);\n\twindow['wsAdminCustomizerPreview'] = previewHandler;\n\n\t$('body').trigger('adminMenuEditor:acPreviewStart', [previewHandler]);\n}\n\ndeclare global {\n\tinterface Window {\n\t\twsAdminCustomizerPreview: AmeAdminCustomizerPreview.PreviewHandler;\n\t}\n}","'use strict';\nexport var AmeAdminCustomizerBase;\n(function (AmeAdminCustomizerBase) {\n    class AdminCustomizerBase {\n        constructor(scriptData) {\n            this.allowedCommOrigins = scriptData.allowedCommOrigins;\n            if (this.allowedCommOrigins.length === 0) {\n                this.allowedCommOrigins = [window.location.origin];\n            }\n            this.allowedPreviewUrls = scriptData.allowedPreviewUrls;\n            this.parsedAllowedUrls = this.allowedPreviewUrls.map(url => new URL(url));\n        }\n        isPreviewableUrl(url) {\n            if (typeof url === 'string') {\n                url = new URL(url);\n            }\n            if (typeof url.protocol === 'undefined') {\n                return false;\n            }\n            //Only HTTP(S) links are previewable.\n            if ((url.protocol !== 'http:') && (url.protocol !== 'https:')) {\n                return false;\n            }\n            //Check against the list of allowed URLs.\n            for (const allowedUrl of this.parsedAllowedUrls) {\n                //Protocol and host must match. The path must start with the path\n                //of the allowed URL (possibly without a trailing slash).\n                if ((url.protocol === allowedUrl.protocol) && (url.host === allowedUrl.host)) {\n                    const allowedPath = allowedUrl.pathname.replace(/\\/$/, '');\n                    if (url.pathname.indexOf(allowedPath) === 0) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    AmeAdminCustomizerBase.AdminCustomizerBase = AdminCustomizerBase;\n})(AmeAdminCustomizerBase || (AmeAdminCustomizerBase = {}));\n//# sourceMappingURL=admin-customizer-base.js.map","export var AmeStyleGenerator;\n(function (AmeStyleGenerator) {\n    const $ = jQuery;\n    class ValueDescriptor {\n    }\n    class ConstantValue extends ValueDescriptor {\n        constructor(value) {\n            super();\n            this.value = value;\n        }\n        getValue() {\n            return this.value;\n        }\n    }\n    class ArrayValue extends ValueDescriptor {\n        constructor(items) {\n            super();\n            this.items = items;\n        }\n        getValue() {\n            return this.items.map(item => item.getValue());\n        }\n        getItemDescriptors() {\n            return this.items;\n        }\n    }\n    class SettingReference extends ValueDescriptor {\n        constructor(settingId, valueGetter) {\n            super();\n            this.settingId = settingId;\n            this.valueGetter = valueGetter;\n        }\n        getValue() {\n            return this.valueGetter(this.settingId);\n        }\n    }\n    class VariableReference extends ValueDescriptor {\n        constructor(name, valueGetter) {\n            super();\n            this.name = name;\n            this.valueGetter = valueGetter;\n        }\n        getValue() {\n            return this.valueGetter(this.name);\n        }\n    }\n    class FunctionCall extends ValueDescriptor {\n        constructor(args, callback) {\n            super();\n            this.args = args;\n            this.callback = callback;\n        }\n        getValue() {\n            return this.callback(this.resolveArgs(this.args));\n        }\n        resolveArgs(args) {\n            if (Array.isArray(args)) {\n                return args.map(arg => arg.getValue());\n            }\n            return Object.keys(args).reduce((result, key) => {\n                result[key] = args[key].getValue();\n                return result;\n            }, {});\n        }\n    }\n    //endregion\n    function isEmptyCssValue(value) {\n        return (typeof value === 'undefined') || (value === '') || (value === null);\n    }\n    function convertToRgba(color, opacity = 1.0) {\n        color = color.trim();\n        if (color === '') {\n            return 'transparent';\n        }\n        //Strip the leading hash, if any.\n        if (color[0] === '#') {\n            color = color.substring(1);\n        }\n        //If the color is in the shorthand format, expand it.\n        if (color.length === 3) {\n            color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n        }\n        //The color should now be in the full 6-digit format. Convert it to RGBA.\n        if (color.length === 6) {\n            const red = parseInt(color.substring(0, 2), 16);\n            const green = parseInt(color.substring(2, 4), 16);\n            const blue = parseInt(color.substring(4, 6), 16);\n            return `rgba(${red}, ${green}, ${blue}, ${opacity})`;\n        }\n        //The color may be invalid, or it's not in a hex format we recognize.\n        return color;\n    }\n    function uniqueArrayValues(array) {\n        return array.filter((value, index) => array.indexOf(value) === index);\n    }\n    function constrain(value, min, max) {\n        return Math.min(Math.max(value, min), max);\n    }\n    function modifyHexColorAsHsl(args, operation) {\n        const color = args.color || '';\n        if (isEmptyCssValue(color)) {\n            return '';\n        }\n        const hue = args.hue || null;\n        const saturation = args.saturation || null;\n        const lightness = args.lightness || null;\n        if ((hue === null) && (saturation === null) && (lightness === null)) {\n            return color;\n        }\n        let output = $.Color(color);\n        output = operation(output, hue, saturation, lightness);\n        return output.toHexString();\n    }\n    // noinspection JSUnusedGlobalSymbols -- Used dynamically by declaration generators received from the server.\n    const builtinFunctions = {\n        simpleProperty: function (args) {\n            if (isEmptyCssValue(args.value)) {\n                return [];\n            }\n            return [args.name + ': ' + args.value + ';'];\n        },\n        formatLength: function (args) {\n            if (isEmptyCssValue(args.value)) {\n                return '';\n            }\n            //Normalize numeric values. For example, while JS accepts \"1.\" as a number,\n            //\"1.px\" is not a valid CSS length value, so it should be converted to \"1px\".\n            const numericValue = parseFloat(String(args.value));\n            if (isNaN(numericValue)) {\n                return '';\n            }\n            return '' + numericValue + (args.unit || '');\n        },\n        shadow: function (args) {\n            const mode = args.mode || 'default';\n            const color = args.color || '';\n            if (mode === 'default') {\n                return [];\n            }\n            if ((mode === 'none') || (color === '') || (color === null) || (color === 'transparent')) {\n                return ['box-shadow: none;'];\n            }\n            if (mode !== 'custom') {\n                return [];\n            }\n            const components = [];\n            if (args.inset) {\n                components.push('inset');\n            }\n            const horizontal = args['offset-x'] || 0;\n            const vertical = args['offset-y'] || 0;\n            const blur = args.blur || 0;\n            const spread = args.spread || 0;\n            components.push(`${horizontal}px ${vertical}px ${blur}px ${spread}px`);\n            const colorOpacity = args.colorOpacity || 1.0;\n            if (colorOpacity < 1.0) {\n                components.push(convertToRgba(color, colorOpacity));\n            }\n            else {\n                components.push(color);\n            }\n            return [`box-shadow: ${components.join(' ')};`];\n        },\n        boxSides: function (args) {\n            if (typeof args.cssPropertyPrefix !== 'string') {\n                throw new Error('Invalid config for the boxSides generator: missing cssPropertyPrefix');\n            }\n            const compositeValue = args.value || {};\n            const unit = compositeValue.unit || '';\n            const declarations = [];\n            for (const side of ['top', 'right', 'bottom', 'left']) {\n                const value = compositeValue[side];\n                if (isEmptyCssValue(value)) {\n                    continue;\n                }\n                const property = args.cssPropertyPrefix + side;\n                declarations.push(`${property}: ${value}${unit};`);\n            }\n            return declarations;\n        },\n        firstNonEmpty(args) {\n            for (const arg of args) {\n                if (!isEmptyCssValue(arg)) {\n                    return arg;\n                }\n            }\n            return null;\n        },\n        /**\n         * Take a HEX color, convert it to HSL to edit its components,\n         * then convert back to HEX.\n         *\n         * @param args\n         */\n        editHexAsHsl: function (args) {\n            return modifyHexColorAsHsl(args, (color, hue, saturation, lightness) => {\n                if (hue !== null) {\n                    color = color.hue(hue);\n                }\n                if (saturation !== null) {\n                    color = color.saturation(saturation);\n                }\n                if (lightness !== null) {\n                    color = color.lightness(lightness);\n                }\n                return color;\n            });\n        },\n        adjustHexAsHsl: function (args) {\n            return modifyHexColorAsHsl(args, (color, hue, saturation, lightness) => {\n                if (hue !== null) {\n                    color = color.hue(constrain(color.hue() + hue, 0, 360));\n                }\n                if (saturation !== null) {\n                    color = color.saturation(constrain(color.saturation() + saturation, 0, 1.0));\n                }\n                if (lightness !== null) {\n                    color = color.lightness(constrain(color.lightness() + lightness, 0, 1.0));\n                }\n                return color;\n            });\n        },\n        mixColors: function (args) {\n            const color1 = args.color1 || '';\n            const color2 = args.color2 || '';\n            if (isEmptyCssValue(color1) || isEmptyCssValue(color2)) {\n                return '';\n            }\n            const weight = args.weight || 50;\n            if (weight <= 0) {\n                return color2;\n            }\n            else if (weight >= 100) {\n                return color1;\n            }\n            return $.Color(color2).transition($.Color(color1), weight / 100).toHexString();\n        },\n        changeLightness: function (args) {\n            const color = args.color || '';\n            if (isEmptyCssValue(color)) {\n                return '';\n            }\n            const amount = args.amount || 0;\n            if (amount === 0) {\n                return color;\n            }\n            let output = $.Color(color);\n            //Amount is a number between 0 and 100, while lightness is between 0.0 and 1.0.\n            let newLightness = output.lightness() + (amount / 100);\n            //Clamp to 0.0 - 1.0.\n            newLightness = constrain(newLightness, 0.0, 1.0);\n            return output.lightness(newLightness).toHexString();\n        },\n        darken: function (args) {\n            const color = args.color || '';\n            const amount = args.amount || 0;\n            return builtinFunctions.changeLightness({ color, amount: -Math.abs(amount) });\n        },\n        lighten: function (args) {\n            const color = args.color || '';\n            const amount = args.amount || 0;\n            return builtinFunctions.changeLightness({ color, amount: Math.abs(amount) });\n        },\n        compare: function (args) {\n            const value1 = args.value1;\n            const value2 = args.value2;\n            const operator = args.op;\n            const thenResult = (typeof args.thenResult !== 'undefined') ? args.thenResult : true;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            let result;\n            switch (operator) {\n                case '==':\n                    result = value1 == value2;\n                    break;\n                case '!=':\n                    result = value1 != value2;\n                    break;\n                case '>':\n                    result = value1 > value2;\n                    break;\n                case '>=':\n                    result = value1 >= value2;\n                    break;\n                case '<':\n                    result = value1 < value2;\n                    break;\n                case '<=':\n                    result = value1 <= value2;\n                    break;\n                default:\n                    throw new Error(`Unknown operator: ${operator}`);\n            }\n            return result ? thenResult : elseResult;\n        },\n        ifTruthy: function (args) {\n            const value = args.value;\n            const thenResult = (typeof args.thenResult !== 'undefined') ? args.thenResult : true;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            return value ? thenResult : elseResult;\n        },\n        ifSome: function (args) {\n            const values = args.values;\n            const thenResult = args.thenResult;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            for (const value of values) {\n                if (!!value) {\n                    return thenResult;\n                }\n            }\n            return elseResult;\n        },\n        ifAll: function (args) {\n            const values = args.values;\n            const thenResult = args.thenResult;\n            const elseResult = args.elseResult !== undefined ? args.elseResult : null;\n            if (!values || (values.length === 0)) {\n                return elseResult;\n            }\n            for (const value of values) {\n                if (!value) {\n                    return elseResult;\n                }\n            }\n            return thenResult;\n        },\n        ifImageSettingContainsImage: function (args) {\n            const thenResult = args.thenResult !== undefined ? args.thenResult : true;\n            const elseResult = args.elseResult !== undefined ? args.elseResult : null;\n            if ((typeof args.value !== 'object') || !args.value) {\n                return elseResult;\n            }\n            const image = args.value;\n            const hasAttachment = !!image.attachmentId;\n            const hasExternalUrl = !!image.externalUrl;\n            const hasImage = hasAttachment || hasExternalUrl;\n            return hasImage ? thenResult : elseResult;\n        }\n    };\n    let Preview;\n    (function (Preview) {\n        const $ = jQuery;\n        function isConditionalAtRuleConfig(config) {\n            if ((typeof config !== 'object') || (config === null)) {\n                return false;\n            }\n            const configAsRecord = config;\n            return ((typeof configAsRecord['t'] === 'string')\n                && (configAsRecord['t'] === 'conditionalAtRule')\n                && (typeof configAsRecord['identifier'] === 'string'));\n        }\n        function isRuleSetConfig(config) {\n            return ((config !== null)\n                && (Array.isArray(config['selectors']))\n                && (Array.isArray(config['generators'])));\n        }\n        const inactiveSettingMarker = { '_ame_inactive_setting': true };\n        class PreviewSession {\n            constructor(config) {\n                this.settings = {};\n                this.valueReaders = new Set();\n                this.notFound = {};\n                this.variables = {};\n                this.styleBlocks = [];\n                this.stylesheetsToDisable = [];\n                this.stylesheetWasEnabled = {};\n                /**\n                 * Whether this is the first time the preview is being updated.\n                 * This is set to false after preview() is called for the first time.\n                 */\n                this._isBeforeFirstUpdate = true;\n                //Optimization: Create bound getters once instead of every time we need\n                //to create a setting or variable reference.\n                this.settingValueGetter = this.getSettingPreviewValue.bind(this);\n                this.variableValueGetter = (variableName) => {\n                    if (variableName in this.variables) {\n                        return this.variables[variableName].getValue();\n                    }\n                    return null;\n                };\n                //Optionally, disable already generated custom stylesheets while the preview\n                //is active to prevent old settings from interfering with the preview of new settings.\n                if (Array.isArray(config.stylesheetsToDisable)) {\n                    this.stylesheetsToDisable = config.stylesheetsToDisable;\n                }\n                //Variables\n                for (const variableName in config.variables) {\n                    if (!config.variables.hasOwnProperty(variableName)) {\n                        continue;\n                    }\n                    this.variables[variableName] = this.createValueDescriptor(config.variables[variableName], true);\n                }\n                //CSS statement groups\n                for (const conditionConfig of config.statementGroups) {\n                    const statements = this.createCssStatements(conditionConfig.statements);\n                    if (statements.length < 1) {\n                        continue;\n                    }\n                    const condition = this.createValueDescriptor(conditionConfig.expression, true);\n                    const usedSettingIds = this.getSettingIdsUsedBy(condition);\n                    const conditionCallback = () => {\n                        //For performance, conditions that reference settings should\n                        //only be checked when at least one setting is active.\n                        if (usedSettingIds.length > 0) {\n                            if (!usedSettingIds.some((id) => this.isSettingActive(id))) {\n                                return false;\n                            }\n                        }\n                        const isTruthy = condition.getValue();\n                        return !!isTruthy; //Convert to boolean.\n                    };\n                    this.styleBlocks.push(new PreviewStyleBlock(statements, conditionCallback));\n                }\n            }\n            createValueDescriptor(data, allowUnknownVariables = false) {\n                switch (data.t) {\n                    case 'constant':\n                        return new ConstantValue(data.value);\n                    case 'array':\n                        return new ArrayValue(data.items.map((valueData) => this.createValueDescriptor(valueData, allowUnknownVariables)));\n                    case 'setting':\n                        this.registerPreviewableSettingId(data.id);\n                        return new SettingReference(data.id, this.settingValueGetter);\n                    case 'var':\n                        if (!this.variables.hasOwnProperty(data.name) && !allowUnknownVariables) {\n                            throw new Error('Unknown variable: ' + data.name);\n                        }\n                        return new VariableReference(data.name, this.variableValueGetter);\n                    case 'funcCall':\n                        let functionName;\n                        if (data.name in builtinFunctions) {\n                            functionName = data.name;\n                        }\n                        else {\n                            throw new Error('Unknown function: ' + data.name);\n                        }\n                        const func = builtinFunctions[functionName];\n                        //Initialize the function arguments.\n                        let args;\n                        if (Array.isArray(data.args)) {\n                            args = data.args.map(arg => this.createValueDescriptor(arg, allowUnknownVariables));\n                        }\n                        else {\n                            args = {};\n                            for (const argName in data.args) {\n                                if (!data.args.hasOwnProperty(argName)) {\n                                    continue;\n                                }\n                                args[argName] = this.createValueDescriptor(data.args[argName], allowUnknownVariables);\n                            }\n                        }\n                        // @ts-ignore - Can't really statically check this since the values come from the server.\n                        return new FunctionCall(args, func);\n                }\n            }\n            /**\n             * Get the IDs of all settings that are referenced by the given descriptor.\n             *\n             * @param descriptor\n             * @private\n             */\n            getSettingIdsUsedBy(descriptor) {\n                if (descriptor instanceof SettingReference) {\n                    return [descriptor.settingId];\n                }\n                if (descriptor instanceof ArrayValue) {\n                    let result = [];\n                    for (const item of descriptor.getItemDescriptors()) {\n                        result = result.concat(this.getSettingIdsUsedBy(item));\n                    }\n                    return uniqueArrayValues(result);\n                }\n                if (descriptor instanceof FunctionCall) {\n                    let result = [];\n                    const args = descriptor.args;\n                    if (Array.isArray(args)) {\n                        for (const arg of args) {\n                            result = result.concat(this.getSettingIdsUsedBy(arg));\n                        }\n                    }\n                    else {\n                        for (const argName in args) {\n                            if (args.hasOwnProperty(argName)) {\n                                result = result.concat(this.getSettingIdsUsedBy(args[argName]));\n                            }\n                        }\n                    }\n                    return uniqueArrayValues(result);\n                }\n                if (descriptor instanceof VariableReference) {\n                    const varDef = this.getVariableDefinition(descriptor.name);\n                    if (varDef === null) {\n                        return [];\n                    }\n                    return this.getSettingIdsUsedBy(varDef);\n                }\n                return [];\n            }\n            getVariableDefinition(variableName) {\n                if (!this.variables.hasOwnProperty(variableName)) {\n                    return null;\n                }\n                return this.variables[variableName];\n            }\n            createCssStatements(configs) {\n                let results = [];\n                for (const config of configs) {\n                    if (isRuleSetConfig(config)) {\n                        results.push(this.createRuleSetFromConfig(config));\n                    }\n                    else if (isConditionalAtRuleConfig(config)) {\n                        results.push(new ConditionalAtRule(config.identifier, config.condition, (typeof config.nestedStatements === 'undefined')\n                            ? []\n                            : this.createCssStatements(config.nestedStatements)));\n                    }\n                    else {\n                        console.error('Unknown CSS statement type: ', config);\n                    }\n                }\n                return results;\n            }\n            createRuleSetFromConfig(config, parent = null) {\n                const generatorWrappers = this.makeGeneratorWrappers(config.generators);\n                const ruleSet = new CssRuleSet(config.selectors, generatorWrappers, parent);\n                const nestedRuleSets = this.createNestedRuleSets(config.nestedStatements, ruleSet);\n                ruleSet.setNestedRuleSets(nestedRuleSets);\n                return ruleSet;\n            }\n            createNestedRuleSets(configs, parent = null) {\n                let results = [];\n                if (!configs) {\n                    return results;\n                }\n                for (const config of configs) {\n                    if (!isRuleSetConfig(config)) {\n                        throw new Error('A CSS rule set can only contain other rule sets, not other types of statements.');\n                    }\n                    results.push(this.createRuleSetFromConfig(config, parent));\n                }\n                return results;\n            }\n            getPreviewableSettingIDs() {\n                return Object.keys(this.settings);\n            }\n            preview(settingId, value, otherSettingReader) {\n                if (this._isBeforeFirstUpdate) {\n                    this._isBeforeFirstUpdate = false;\n                    this.disableAssociatedStylesheets();\n                }\n                this.valueReaders.add(otherSettingReader);\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    this.settings[settingId] = ko.observable(value);\n                }\n                else {\n                    this.settings[settingId](value);\n                }\n            }\n            dispose() {\n                //Dispose of all style blocks.\n                for (const block of this.styleBlocks) {\n                    block.dispose();\n                }\n                this.reEnableAssociatedStylesheets();\n            }\n            disableAssociatedStylesheets() {\n                for (const stylesheetSelector of this.stylesheetsToDisable) {\n                    const $link = $(stylesheetSelector);\n                    if ($link.length > 0) {\n                        this.stylesheetWasEnabled[stylesheetSelector] = $link.prop('disabled');\n                        $link.prop('disabled', true);\n                    }\n                }\n            }\n            reEnableAssociatedStylesheets() {\n                for (const stylesheetSelector of this.stylesheetsToDisable) {\n                    const $link = $(stylesheetSelector);\n                    if (($link.length > 0) && this.stylesheetWasEnabled.hasOwnProperty(stylesheetSelector)) {\n                        $link.prop('disabled', this.stylesheetWasEnabled[stylesheetSelector]);\n                    }\n                }\n            }\n            isSettingActive(settingId) {\n                if (this.settings.hasOwnProperty(settingId)) {\n                    return this.settings[settingId]() !== inactiveSettingMarker;\n                }\n                return false;\n            }\n            getSettingPreviewValue(settingId) {\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    const value = this.getSettingFromReaders(settingId);\n                    this.settings[settingId] = ko.observable(value).extend({ deferred: true });\n                }\n                const observable = this.settings[settingId];\n                let value = observable();\n                if (value === inactiveSettingMarker) {\n                    value = this.getSettingFromReaders(settingId);\n                    observable(value);\n                }\n                return value;\n            }\n            getSettingFromReaders(settingId) {\n                for (const reader of this.valueReaders) {\n                    const value = reader(settingId, this.notFound);\n                    if (value !== this.notFound) {\n                        return value;\n                    }\n                }\n                throw new Error('Setting not found for preview: ' + settingId);\n            }\n            makeGeneratorWrappers(generatorConfigs) {\n                let generatorWrappers = [];\n                for (const generatorConfig of generatorConfigs) {\n                    const wrapper = this.makeDeclarationGeneratorWrapper(generatorConfig);\n                    if (wrapper !== null) {\n                        generatorWrappers.push(wrapper);\n                    }\n                }\n                return generatorWrappers;\n            }\n            makeDeclarationGeneratorWrapper(config) {\n                const generator = this.createValueDescriptor(config);\n                return new DeclarationGeneratorWrapper(generator, this);\n            }\n            registerPreviewableSettingId(settingId) {\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    this.settings[settingId] = ko.observable(inactiveSettingMarker);\n                }\n            }\n            get isBeforeFirstUpdate() {\n                return this._isBeforeFirstUpdate;\n            }\n        }\n        /**\n         * Preview manager for the style generator.\n         *\n         * This is a thin wrapper around the PreviewSession class. It initializes the session\n         * as needed and destroys it when the preview is cleared. This makes it simpler to manage\n         * active settings, style blocks, and CSS rule-sets: instead of having to carefully\n         * track dependencies and deactivate/reactivate them in the right order whenever the preview\n         * is disabled/enabled, we can just destroy the session and start over.\n         */\n        class StyleGeneratorPreview {\n            constructor(config) {\n                this.config = config;\n                this.currentSession = null;\n            }\n            getOrCreateSession() {\n                if (this.currentSession === null) {\n                    this.currentSession = new PreviewSession(this.config);\n                }\n                return this.currentSession;\n            }\n            getPreviewableSettingIDs() {\n                return this.getOrCreateSession().getPreviewableSettingIDs();\n            }\n            preview(settingId, value, otherSettingReader) {\n                const session = this.getOrCreateSession();\n                const shouldPreviewAll = (this.config.previewAllOnFirstUpdate && session.isBeforeFirstUpdate);\n                session.preview(settingId, value, otherSettingReader);\n                if (shouldPreviewAll) {\n                    //Preview all registered settings the first time the preview is updated.\n                    const notFound = {};\n                    for (const otherId of session.getPreviewableSettingIDs()) {\n                        const otherValue = otherSettingReader(otherId, notFound);\n                        if ((otherId !== settingId) && (otherValue !== notFound)) {\n                            session.preview(otherId, otherValue, otherSettingReader);\n                        }\n                    }\n                }\n            }\n            clearPreview() {\n                if (this.currentSession !== null) {\n                    this.currentSession.dispose();\n                    this.currentSession = null;\n                }\n            }\n        }\n        Preview.StyleGeneratorPreview = StyleGeneratorPreview;\n        class DeclarationGeneratorWrapper {\n            constructor(generator, settingSource) {\n                this.generator = generator;\n                this.settingSource = settingSource;\n                //Introspect the generator and see which settings it uses.\n                //This will be useful to determine if the generator is active.\n                this.usedSettingIds = DeclarationGeneratorWrapper.findReferencedSettingIds(generator, settingSource);\n                this.cssDeclarations = ko.computed({\n                    read: () => this.getDeclarations(),\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n            }\n            /**\n             * Recursively find all settings used by a value descriptor (such as a function call).\n             *\n             * @param {ValueDescriptor} thing\n             * @param variableSource Needed to get variable definitions and not just the final values.\n             */\n            static findReferencedSettingIds(thing, variableSource) {\n                let settingIds = [];\n                if (thing instanceof SettingReference) {\n                    settingIds.push(thing.settingId);\n                }\n                else if (thing instanceof FunctionCall) {\n                    if (Array.isArray(thing.args)) {\n                        for (const arg of thing.args) {\n                            settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(arg, variableSource));\n                        }\n                    }\n                    else {\n                        for (const key in thing.args) {\n                            settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(thing.args[key], variableSource));\n                        }\n                    }\n                }\n                else if (thing instanceof VariableReference) {\n                    const value = variableSource.getVariableDefinition(thing.name);\n                    if (value !== null) {\n                        settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(value, variableSource));\n                    }\n                }\n                return settingIds;\n            }\n            isActive() {\n                //Check if any of the input settings are active.\n                let hasSettingLookups = false;\n                for (const settingId of this.usedSettingIds) {\n                    hasSettingLookups = true;\n                    if (this.settingSource.isSettingActive(settingId)) {\n                        return true;\n                    }\n                }\n                //If there are no input settings, the generator is always active: it just\n                //generates a fixed declaration.\n                return !hasSettingLookups;\n            }\n            getDeclarations() {\n                return this.generator.getValue();\n            }\n            dispose() {\n                this.cssDeclarations.dispose();\n            }\n        }\n        class CssStatement {\n            constructor() {\n                this.cssText = ko.computed({\n                    read: () => this.generateCss(),\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n            }\n            dispose() {\n                //Dispose the CSS text observable.\n                this.cssText.dispose();\n            }\n        }\n        class CssRuleSet extends CssStatement {\n            constructor(selectors, declarationSources, parent = null) {\n                super();\n                this.declarationSources = declarationSources;\n                this.nestedRuleSets = ko.observableArray([]);\n                if (parent === null) {\n                    this.effectiveSelectors = selectors;\n                }\n                else {\n                    this.effectiveSelectors = CssRuleSet.combineSelectors(selectors, parent.effectiveSelectors);\n                }\n                this.selectorText = this.effectiveSelectors.join(', ');\n            }\n            static combineSelectors(selectors, parentSelectors) {\n                const combinedSelectors = [];\n                for (const selector of selectors) {\n                    if (selector === '') {\n                        continue;\n                    }\n                    if (selector.includes('&')) {\n                        //Insert the parent selectors into the current selector at the position of the \"&\".\n                        for (const parentSelector of parentSelectors) {\n                            combinedSelectors.push(selector.replace('&', parentSelector.trim()));\n                        }\n                    }\n                    else {\n                        //Just append the current selector to the parent selectors.\n                        for (const parentSelector of parentSelectors) {\n                            combinedSelectors.push(`${parentSelector} ${selector}`);\n                        }\n                    }\n                }\n                return combinedSelectors;\n            }\n            setNestedRuleSets(ruleSets) {\n                //Dispose the old rule sets that are not part of the new list.\n                for (const oldRuleSet of this.nestedRuleSets()) {\n                    if (ruleSets.indexOf(oldRuleSet) === -1) {\n                        oldRuleSet.dispose();\n                    }\n                }\n                this.nestedRuleSets(ruleSets);\n            }\n            generateCss() {\n                const declarations = this.getDeclarations();\n                const nestedRuleSetParts = [];\n                for (const ruleSet of this.nestedRuleSets()) {\n                    if (ruleSet.isActive()) {\n                        nestedRuleSetParts.push(ruleSet.cssText());\n                    }\n                }\n                let css = '';\n                if (declarations.length > 0) {\n                    css += this.selectorText + ' {\\n\\t' + declarations.join('\\n\\t') + '\\n}\\n';\n                }\n                if (nestedRuleSetParts.length > 0) {\n                    css += nestedRuleSetParts.join('\\n');\n                }\n                return css;\n            }\n            isActive() {\n                for (const source of this.declarationSources) {\n                    if (source.isActive()) {\n                        return true;\n                    }\n                }\n                for (const ruleSet of this.nestedRuleSets()) {\n                    if (ruleSet.isActive()) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            getDeclarations() {\n                const declarations = [];\n                for (const source of this.declarationSources) {\n                    if (source.isActive()) {\n                        declarations.push(...source.cssDeclarations());\n                    }\n                }\n                return declarations;\n            }\n            dispose() {\n                //Dispose declaration sources.\n                for (const source of this.declarationSources) {\n                    source.dispose();\n                }\n                //Dispose nested rule sets.\n                for (const ruleSet of this.nestedRuleSets()) {\n                    ruleSet.dispose();\n                }\n                super.dispose();\n            }\n        }\n        class ConditionalAtRule extends CssStatement {\n            constructor(identifier, condition, nestedStatements) {\n                super();\n                this.identifier = identifier;\n                this.condition = condition;\n                this.nestedStatements = nestedStatements;\n            }\n            generateCss() {\n                const pieces = [];\n                for (const statement of this.nestedStatements) {\n                    const css = statement.cssText();\n                    if (css !== '') {\n                        pieces.push(css);\n                    }\n                }\n                if (pieces.length === 0) {\n                    return '';\n                }\n                return this.getAtRuleText() + ' {\\n\\t' + pieces.join('\\n\\t') + '\\n}';\n            }\n            getAtRuleText() {\n                return '@' + this.identifier + ' ' + this.condition;\n            }\n            isActive() {\n                for (const statement of this.nestedStatements) {\n                    if (statement.isActive()) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            dispose() {\n                //Dispose nested statements.\n                for (const statement of this.nestedStatements) {\n                    statement.dispose();\n                }\n                super.dispose();\n            }\n        }\n        class PreviewStyleBlock {\n            constructor(statements, condition = null) {\n                this.statements = statements;\n                this.condition = condition;\n                this.$styleElement = null;\n                this.cssText = ko.computed({\n                    read: () => {\n                        if ((condition !== null) && !condition()) {\n                            return '';\n                        }\n                        let pieces = [];\n                        for (const statement of this.statements) {\n                            if (statement.isActive()) {\n                                const css = statement.cssText();\n                                if (css !== '') {\n                                    pieces.push(css);\n                                }\n                            }\n                        }\n                        if (pieces.length === 0) {\n                            return '';\n                        }\n                        return pieces.join('\\n');\n                    },\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n                this.updateStyleElement(this.cssText());\n                this.cssChangeSubscription = this.cssText.subscribe((cssText) => {\n                    this.updateStyleElement(cssText);\n                });\n            }\n            updateStyleElement(cssText) {\n                if (cssText === '') {\n                    if (this.$styleElement) {\n                        this.$styleElement.remove();\n                        this.$styleElement = null;\n                    }\n                    return;\n                }\n                if (!this.$styleElement) {\n                    this.$styleElement = $('<style></style>').appendTo('head');\n                }\n                this.$styleElement.text(cssText);\n            }\n            clear() {\n                if (this.$styleElement) {\n                    this.$styleElement.remove();\n                    this.$styleElement = null;\n                }\n            }\n            dispose() {\n                //Stop listening for CSS changes.\n                this.cssChangeSubscription.dispose();\n                this.cssText.dispose();\n                //Dispose rule sets.\n                for (const ruleset of this.statements) {\n                    ruleset.dispose();\n                }\n                //Remove the style element.\n                this.clear();\n            }\n        }\n    })(Preview = AmeStyleGenerator.Preview || (AmeStyleGenerator.Preview = {}));\n})(AmeStyleGenerator || (AmeStyleGenerator = {}));\n//# sourceMappingURL=style-generator.js.map"],"names":[],"sourceRoot":""}