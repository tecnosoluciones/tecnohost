{"version":3,"file":"menu-styler-ui.bundle.js","mappings":"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AAI,MAAM,IAAI,KAAK,IAAI,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW,KAAK,SAAS,KAAK,KAAK,KAAK,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS,IAAI,MAAM,EAAE,MAAM;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,kCAAkC;AACxF,SAAS;AACT;AACA;AACA;AACA,sDAAsD,iCAAiC;AACvF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB,EAAE,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wCAAwC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,WAAW,gBAAgB;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wEAAwE;AAC7E,CAAC,8CAA8C;AAC/C","sources":["webpack:///./extras/modules/menu-styler/menu-styler-ui.ts","webpack:///./extras/style-generator/style-generator.js"],"sourcesContent":["///<reference path=\"../../../js/common.d.ts\"/>\n///<reference path=\"../../../js/jquery.biscuit.d.ts\"/>\n\nimport {AmeStyleGenerator} from '../../style-generator/style-generator.js';\nimport {AmeCustomizableViewModel} from '../../pro-customizables/assets/customizable.js';\n\ndeclare var wsAmeLodash: _.LoDashStatic;\n\ndeclare const ameMenuStylerConfig: {\n\tdefaults: Record<string, unknown>,\n\tstylePreviewConfigs: AmeStyleGenerator.Preview.StyleGeneratorPreviewConfig[]\n};\n\njQuery(function ($: JQueryStatic) {\n\tconst _ = wsAmeLodash;\n\n\tconst styleConfigKey = 'menu_styles';\n\n\t/**\n\t * Utility class that tells WordPress to pin or unpin the admin menu as needed\n\t * when the menu dimensions or the top margin change.\n\t *\n\t * Uses throttling to avoid excessive updates.\n\t */\n\tclass StickyMenuUpdater {\n\t\tprivate readonly $document = $(document);\n\t\tprivate readonly $adminmenu = $('#adminmenu');\n\n\t\tprivate previousHeight: number | null = null;\n\t\tprivate previousWidth: number | null = null;\n\t\tprivate previousTopMargin: number | null = null;\n\n\t\tprivate readonly updateMenuPinState = _.throttle(() => {\n\t\t\tconst menuHeight = this.$adminmenu.outerHeight();\n\t\t\tconst menuWidth = this.$adminmenu.outerWidth();\n\t\t\tconst topMargin = parseInt(this.$adminmenu.css('margin-top'), 10);\n\n\t\t\tif (\n\t\t\t\t(menuHeight !== this.previousHeight)\n\t\t\t\t|| (menuWidth !== this.previousWidth)\n\t\t\t\t|| (topMargin !== this.previousTopMargin)\n\t\t\t) {\n\t\t\t\tthis.previousHeight = menuHeight;\n\t\t\t\tthis.previousWidth = menuWidth;\n\t\t\t\tthis.previousTopMargin = topMargin;\n\n\t\t\t\t//In practice, this update doesn't always work if done immediately.\n\t\t\t\t//Not sure why, maybe menu dimensions don't change instantly when, for example,\n\t\t\t\t//the user adds a logo image. Adding a small delay seems to help.\n\t\t\t\twindow.requestAnimationFrame(() => {\n\t\t\t\t\t//The custom \"wp-pin-menu\" event was added to WP core in 2015. It can be used to update\n\t\t\t\t\t//the menu \"sticky\" state. I'm using triggerHandler() instead of trigger() because this\n\t\t\t\t\t//is what /wp-admin/js/widgets.js does. Hopefully, that will improve compatibility.\n\t\t\t\t\tthis.$document.triggerHandler('wp-pin-menu');\n\t\t\t\t});\n\t\t\t}\n\t\t}, 1000, {leading: true, trailing: true});\n\n\t\tpublic queueUpdate(): void {\n\t\t\tthis.updateMenuPinState();\n\t\t}\n\t}\n\n\tclass MenuStylerViewModel extends AmeCustomizableViewModel.SimpleVm {\n\t\tprivate readonly dialogOpenObservable: KnockoutObservable<boolean>;\n\t\tprivate isFirstOpen = true;\n\t\tprivate $dialog: JQuery | null = null;\n\n\t\tprivate previewPreference: WsAmePreferenceCookie;\n\n\t\tprivate stickyMenuUpdater: StickyMenuUpdater = new StickyMenuUpdater();\n\n\t\tconstructor() {\n\t\t\t/**\n\t\t\t * This observable is initially stored in a local variable because TypeScript doesn't\n\t\t\t * allow accessing `this` in the constructor before calling super(), but we still\n\t\t\t * want to establish a dependency on the dialog open state so that preview gets enabled\n\t\t\t * when the dialog is open. The observable will get updated later.\n\t\t\t */\n\t\t\tconst extraPreviewCondition = ko.observable(false);\n\n\t\t\tsuper(extraPreviewCondition);\n\n\t\t\tthis.dialogOpenObservable = extraPreviewCondition;\n\t\t\tthis.previewPreference = new WsAmePreferenceCookie('MsPreviewEnabled', 90, true);\n\n\t\t\t//Read settings from the currently loaded admin menu configuration\n\t\t\t//using the aux-data API. Setting ID prefixes should already be registered.\n\t\t\tconst auxDataSettingReader = (settingId: string, defaultValue: any): any => {\n\t\t\t\tconst path = AmeEditorApi.configDataAdapter.mapSettingIdToPath(settingId);\n\t\t\t\tif (path === null) {\n\t\t\t\t\treturn defaultValue;\n\t\t\t\t}\n\n\t\t\t\tconst value = AmeEditorApi.configDataAdapter.getPath(path, this.notFound);\n\t\t\t\tif (value !== this.notFound) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else if (ameMenuStylerConfig.defaults.hasOwnProperty(settingId)) {\n\t\t\t\t\treturn ameMenuStylerConfig.defaults[settingId];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Unknown aux config setting ID: ' + settingId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (const auxPrefix of AmeEditorApi.configDataAdapter.getKnownPrefixes()) {\n\t\t\t\tthis.registerSettingReader(auxDataSettingReader, auxPrefix);\n\t\t\t}\n\n\t\t\tfor (const previewConfig of ameMenuStylerConfig.stylePreviewConfigs) {\n\t\t\t\tconst previewInstance = new AmeStyleGenerator.Preview.StyleGeneratorPreview(previewConfig);\n\t\t\t\tthis.registerPreviewUpdater(previewInstance.getPreviewableSettingIDs(), previewInstance);\n\t\t\t}\n\n\t\t\t$(document).trigger('adminMenuEditor:menuStylerUiRegister', [this]);\n\t\t}\n\n\t\tsaveChanges() {\n\t\t\tconst settingsById = this.getAllSettingValues();\n\n\t\t\t//Sort by length of the setting ID and then by the ID itself to ensure parent settings\n\t\t\t//are updated before their children. For example, this matters for color presets where\n\t\t\t//the \"activePreset\" setting maps to the \"[global]\" property of the \"colorPresets\" setting.\n\t\t\tconst sortedIds = Object.keys(settingsById);\n\t\t\tsortedIds.sort((a, b) => {\n\t\t\t\tif (a.length !== b.length) {\n\t\t\t\t\treturn a.length - b.length;\n\t\t\t\t}\n\t\t\t\treturn a.localeCompare(b);\n\t\t\t});\n\n\t\t\t//Write all settings into a new object, then save the top-level properties\n\t\t\t//of that. This way stale and empty settings will automatically be removed.\n\t\t\tconst updatedConfig: Record<string, any> = {};\n\t\t\tfor (const settingId of sortedIds) {\n\t\t\t\tconst path = AmeEditorApi.configDataAdapter.mapSettingIdToPath(settingId);\n\t\t\t\tif (path === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst value = settingsById[settingId];\n\t\t\t\t//To save space, don't store null values. This could be extended by using\n\t\t\t\t//the \"deleteWhenBlank\" property of the setting definition.\n\t\t\t\tif (value === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_.set(updatedConfig, path, value);\n\t\t\t}\n\n\t\t\t//Special: Update the last modified timestamp for menu styles.\n\t\t\t_.set(updatedConfig, [styleConfigKey, '_lastModified'], (new Date()).toISOString());\n\n\t\t\t//Special: Remove empty color presets.\n\t\t\tconst colorPresets: Record<string, any> = _.get(updatedConfig, ['color_presets'], {});\n\t\t\tfor (const presetName of Object.keys(colorPresets)) {\n\t\t\t\t//Remove empty string values (i.e. no color selected). This also\n\t\t\t\t//covers nulls and empty arrays/objects, but that shouldn't happen.\n\t\t\t\tcolorPresets[presetName] = _.omitBy(colorPresets[presetName], _.isEmpty);\n\t\t\t\t//Remove the preset if it's empty.\n\t\t\t\tif (_.isEmpty(colorPresets[presetName])) {\n\t\t\t\t\tdelete colorPresets[presetName];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Finally, write the top-level properties to the menu configuration.\n\t\t\tfor (const key in updatedConfig) {\n\t\t\t\tif (!updatedConfig.hasOwnProperty(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst value = updatedConfig[key];\n\t\t\t\tAmeEditorApi.configDataAdapter.setPath(key, value);\n\t\t\t}\n\n\t\t\t$(document).trigger('adminMenuEditor:menuConfigChanged');\n\t\t}\n\n\t\tprotected isDialogOpen(newValue: boolean | null = null): boolean {\n\t\t\tif (!this.dialogOpenObservable) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (newValue !== null) {\n\t\t\t\tthis.dialogOpenObservable(newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\treturn this.dialogOpenObservable();\n\t\t}\n\n\t\tprotected getPreviewActiveState(): boolean {\n\t\t\t//Disable preview when the dialog is not open.\n\t\t\tif (!this.isDialogOpen()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.getPreviewActiveState();\n\t\t}\n\n\t\tupdatePreview(settingIds: string[]) {\n\t\t\tsuper.updatePreview(settingIds);\n\t\t\tthis.stickyMenuUpdater.queueUpdate();\n\t\t}\n\n\t\tsetDialog($dialog: JQuery) {\n\t\t\tthis.$dialog = $dialog;\n\n\t\t\tlet $overlay: JQuery | null = null;\n\n\t\t\t$dialog.on('dialogopen', () => {\n\t\t\t\tthis.isDialogOpen(true);\n\t\t\t\tthis.onOpenDialog();\n\n\t\t\t\t//Add a custom class to the overlay so that we can style it.\n\t\t\t\t$overlay = $dialog.closest('.ui-dialog').nextAll('.ui-widget-overlay').first();\n\t\t\t\t$overlay.addClass('ame-ms-dialog-overlay');\n\t\t\t});\n\t\t\t$dialog.on('dialogclose', () => {\n\t\t\t\tthis.isDialogOpen(false);\n\n\t\t\t\tif ($overlay) {\n\t\t\t\t\t$overlay.removeClass('ame-ms-dialog-overlay');\n\t\t\t\t\t$overlay = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected onOpenDialog() {\n\t\t\tif (!this.isFirstOpen) {\n\t\t\t\tthis.reloadAllSettings();\n\t\t\t}\n\n\t\t\tif (this.isFirstOpen) {\n\t\t\t\tthis.isFirstOpen = false;\n\t\t\t\t//Load the preview state from a cookie.\n\t\t\t\tthis.isPreviewEnabled(this.previewPreference.readAndRefresh(true));\n\t\t\t}\n\t\t}\n\n\t\t// noinspection JSUnusedGlobalSymbols -- Used in the KO template.\n\t\tonConfirmDialog() {\n\t\t\t//Save the preview state in a cookie.\n\t\t\tthis.previewPreference.write(this.isPreviewEnabled());\n\n\t\t\tthis.saveChanges();\n\t\t\tthis.closeDialog();\n\t\t}\n\n\t\tonCancelDialog() {\n\t\t\tthis.closeDialog();\n\t\t}\n\n\t\tprotected closeDialog() {\n\t\t\tif (this.$dialog !== null) {\n\t\t\t\tthis.$dialog.dialog('close');\n\t\t\t}\n\t\t}\n\t}\n\n\tconst $styleDialog = $('#ws-ame-menu-style-settings');\n\tlet isDialogInitialized = false;\n\n\tfunction initializeDialog() {\n\t\t$styleDialog.dialog({\n\t\t\tautoOpen: false,\n\t\t\tcloseText: ' ',\n\t\t\tdraggable: false,\n\t\t\tmodal: true,\n\t\t\t//Dialog dimensions and position are set in CSS.\n\t\t\tminWidth: 300,\n\t\t\theight: 400,\n\t\t\tclasses: {\n\t\t\t\t'ui-dialog': 'ui-corner-all ws-ame-menu-style-dialog',\n\t\t\t}\n\t\t});\n\n\t\tisDialogInitialized = true;\n\n\t\tconst vm = new MenuStylerViewModel();\n\t\t(window as any)['ameMenuStylerVm'] = vm;\n\n\t\tko.applyBindings(vm, $styleDialog[0]);\n\t\tvm.setDialog($styleDialog);\n\t}\n\n\t//Open the dialog when the user clicks the style button.\n\t$('#ws_edit_menu_styles').on('click', () => {\n\t\t//Optimization: Initialize the dialog on the first click.\n\t\tif (!isDialogInitialized) {\n\t\t\tinitializeDialog();\n\t\t}\n\n\t\t//Reset the scroll position of the tab content area.\n\t\t$styleDialog.find('.ame-tp-content').scrollTop(0);\n\n\t\t$styleDialog.dialog('open');\n\t});\n});","export var AmeStyleGenerator;\n(function (AmeStyleGenerator) {\n    const $ = jQuery;\n    class ValueDescriptor {\n    }\n    class ConstantValue extends ValueDescriptor {\n        constructor(value) {\n            super();\n            this.value = value;\n        }\n        getValue() {\n            return this.value;\n        }\n    }\n    class ArrayValue extends ValueDescriptor {\n        constructor(items) {\n            super();\n            this.items = items;\n        }\n        getValue() {\n            return this.items.map(item => item.getValue());\n        }\n        getItemDescriptors() {\n            return this.items;\n        }\n    }\n    class SettingReference extends ValueDescriptor {\n        constructor(settingId, valueGetter) {\n            super();\n            this.settingId = settingId;\n            this.valueGetter = valueGetter;\n        }\n        getValue() {\n            return this.valueGetter(this.settingId);\n        }\n    }\n    class VariableReference extends ValueDescriptor {\n        constructor(name, valueGetter) {\n            super();\n            this.name = name;\n            this.valueGetter = valueGetter;\n        }\n        getValue() {\n            return this.valueGetter(this.name);\n        }\n    }\n    class FunctionCall extends ValueDescriptor {\n        constructor(args, callback) {\n            super();\n            this.args = args;\n            this.callback = callback;\n        }\n        getValue() {\n            return this.callback(this.resolveArgs(this.args));\n        }\n        resolveArgs(args) {\n            if (Array.isArray(args)) {\n                return args.map(arg => arg.getValue());\n            }\n            return Object.keys(args).reduce((result, key) => {\n                result[key] = args[key].getValue();\n                return result;\n            }, {});\n        }\n    }\n    //endregion\n    function isEmptyCssValue(value) {\n        return (typeof value === 'undefined') || (value === '') || (value === null);\n    }\n    function convertToRgba(color, opacity = 1.0) {\n        color = color.trim();\n        if (color === '') {\n            return 'transparent';\n        }\n        //Strip the leading hash, if any.\n        if (color[0] === '#') {\n            color = color.substring(1);\n        }\n        //If the color is in the shorthand format, expand it.\n        if (color.length === 3) {\n            color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n        }\n        //The color should now be in the full 6-digit format. Convert it to RGBA.\n        if (color.length === 6) {\n            const red = parseInt(color.substring(0, 2), 16);\n            const green = parseInt(color.substring(2, 4), 16);\n            const blue = parseInt(color.substring(4, 6), 16);\n            return `rgba(${red}, ${green}, ${blue}, ${opacity})`;\n        }\n        //The color may be invalid, or it's not in a hex format we recognize.\n        return color;\n    }\n    function uniqueArrayValues(array) {\n        return array.filter((value, index) => array.indexOf(value) === index);\n    }\n    function constrain(value, min, max) {\n        return Math.min(Math.max(value, min), max);\n    }\n    function modifyHexColorAsHsl(args, operation) {\n        const color = args.color || '';\n        if (isEmptyCssValue(color)) {\n            return '';\n        }\n        const hue = args.hue || null;\n        const saturation = args.saturation || null;\n        const lightness = args.lightness || null;\n        if ((hue === null) && (saturation === null) && (lightness === null)) {\n            return color;\n        }\n        let output = $.Color(color);\n        output = operation(output, hue, saturation, lightness);\n        return output.toHexString();\n    }\n    // noinspection JSUnusedGlobalSymbols -- Used dynamically by declaration generators received from the server.\n    const builtinFunctions = {\n        simpleProperty: function (args) {\n            if (isEmptyCssValue(args.value)) {\n                return [];\n            }\n            return [args.name + ': ' + args.value + ';'];\n        },\n        formatLength: function (args) {\n            if (isEmptyCssValue(args.value)) {\n                return '';\n            }\n            //Normalize numeric values. For example, while JS accepts \"1.\" as a number,\n            //\"1.px\" is not a valid CSS length value, so it should be converted to \"1px\".\n            const numericValue = parseFloat(String(args.value));\n            if (isNaN(numericValue)) {\n                return '';\n            }\n            return '' + numericValue + (args.unit || '');\n        },\n        shadow: function (args) {\n            const mode = args.mode || 'default';\n            const color = args.color || '';\n            if (mode === 'default') {\n                return [];\n            }\n            if ((mode === 'none') || (color === '') || (color === null) || (color === 'transparent')) {\n                return ['box-shadow: none;'];\n            }\n            if (mode !== 'custom') {\n                return [];\n            }\n            const components = [];\n            if (args.inset) {\n                components.push('inset');\n            }\n            const horizontal = args['offset-x'] || 0;\n            const vertical = args['offset-y'] || 0;\n            const blur = args.blur || 0;\n            const spread = args.spread || 0;\n            components.push(`${horizontal}px ${vertical}px ${blur}px ${spread}px`);\n            const colorOpacity = args.colorOpacity || 1.0;\n            if (colorOpacity < 1.0) {\n                components.push(convertToRgba(color, colorOpacity));\n            }\n            else {\n                components.push(color);\n            }\n            return [`box-shadow: ${components.join(' ')};`];\n        },\n        boxSides: function (args) {\n            if (typeof args.cssPropertyPrefix !== 'string') {\n                throw new Error('Invalid config for the boxSides generator: missing cssPropertyPrefix');\n            }\n            const compositeValue = args.value || {};\n            const unit = compositeValue.unit || '';\n            const declarations = [];\n            for (const side of ['top', 'right', 'bottom', 'left']) {\n                const value = compositeValue[side];\n                if (isEmptyCssValue(value)) {\n                    continue;\n                }\n                const property = args.cssPropertyPrefix + side;\n                declarations.push(`${property}: ${value}${unit};`);\n            }\n            return declarations;\n        },\n        firstNonEmpty(args) {\n            for (const arg of args) {\n                if (!isEmptyCssValue(arg)) {\n                    return arg;\n                }\n            }\n            return null;\n        },\n        /**\n         * Take a HEX color, convert it to HSL to edit its components,\n         * then convert back to HEX.\n         *\n         * @param args\n         */\n        editHexAsHsl: function (args) {\n            return modifyHexColorAsHsl(args, (color, hue, saturation, lightness) => {\n                if (hue !== null) {\n                    color = color.hue(hue);\n                }\n                if (saturation !== null) {\n                    color = color.saturation(saturation);\n                }\n                if (lightness !== null) {\n                    color = color.lightness(lightness);\n                }\n                return color;\n            });\n        },\n        adjustHexAsHsl: function (args) {\n            return modifyHexColorAsHsl(args, (color, hue, saturation, lightness) => {\n                if (hue !== null) {\n                    color = color.hue(constrain(color.hue() + hue, 0, 360));\n                }\n                if (saturation !== null) {\n                    color = color.saturation(constrain(color.saturation() + saturation, 0, 1.0));\n                }\n                if (lightness !== null) {\n                    color = color.lightness(constrain(color.lightness() + lightness, 0, 1.0));\n                }\n                return color;\n            });\n        },\n        mixColors: function (args) {\n            const color1 = args.color1 || '';\n            const color2 = args.color2 || '';\n            if (isEmptyCssValue(color1) || isEmptyCssValue(color2)) {\n                return '';\n            }\n            const weight = args.weight || 50;\n            if (weight <= 0) {\n                return color2;\n            }\n            else if (weight >= 100) {\n                return color1;\n            }\n            return $.Color(color2).transition($.Color(color1), weight / 100).toHexString();\n        },\n        changeLightness: function (args) {\n            const color = args.color || '';\n            if (isEmptyCssValue(color)) {\n                return '';\n            }\n            const amount = args.amount || 0;\n            if (amount === 0) {\n                return color;\n            }\n            let output = $.Color(color);\n            //Amount is a number between 0 and 100, while lightness is between 0.0 and 1.0.\n            let newLightness = output.lightness() + (amount / 100);\n            //Clamp to 0.0 - 1.0.\n            newLightness = constrain(newLightness, 0.0, 1.0);\n            return output.lightness(newLightness).toHexString();\n        },\n        darken: function (args) {\n            const color = args.color || '';\n            const amount = args.amount || 0;\n            return builtinFunctions.changeLightness({ color, amount: -Math.abs(amount) });\n        },\n        lighten: function (args) {\n            const color = args.color || '';\n            const amount = args.amount || 0;\n            return builtinFunctions.changeLightness({ color, amount: Math.abs(amount) });\n        },\n        compare: function (args) {\n            const value1 = args.value1;\n            const value2 = args.value2;\n            const operator = args.op;\n            const thenResult = (typeof args.thenResult !== 'undefined') ? args.thenResult : true;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            let result;\n            switch (operator) {\n                case '==':\n                    result = value1 == value2;\n                    break;\n                case '!=':\n                    result = value1 != value2;\n                    break;\n                case '>':\n                    result = value1 > value2;\n                    break;\n                case '>=':\n                    result = value1 >= value2;\n                    break;\n                case '<':\n                    result = value1 < value2;\n                    break;\n                case '<=':\n                    result = value1 <= value2;\n                    break;\n                default:\n                    throw new Error(`Unknown operator: ${operator}`);\n            }\n            return result ? thenResult : elseResult;\n        },\n        ifTruthy: function (args) {\n            const value = args.value;\n            const thenResult = (typeof args.thenResult !== 'undefined') ? args.thenResult : true;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            return value ? thenResult : elseResult;\n        },\n        ifSome: function (args) {\n            const values = args.values;\n            const thenResult = args.thenResult;\n            const elseResult = (typeof args.elseResult !== 'undefined') ? args.elseResult : null;\n            for (const value of values) {\n                if (!!value) {\n                    return thenResult;\n                }\n            }\n            return elseResult;\n        },\n        ifAll: function (args) {\n            const values = args.values;\n            const thenResult = args.thenResult;\n            const elseResult = args.elseResult !== undefined ? args.elseResult : null;\n            if (!values || (values.length === 0)) {\n                return elseResult;\n            }\n            for (const value of values) {\n                if (!value) {\n                    return elseResult;\n                }\n            }\n            return thenResult;\n        },\n        ifImageSettingContainsImage: function (args) {\n            const thenResult = args.thenResult !== undefined ? args.thenResult : true;\n            const elseResult = args.elseResult !== undefined ? args.elseResult : null;\n            if ((typeof args.value !== 'object') || !args.value) {\n                return elseResult;\n            }\n            const image = args.value;\n            const hasAttachment = !!image.attachmentId;\n            const hasExternalUrl = !!image.externalUrl;\n            const hasImage = hasAttachment || hasExternalUrl;\n            return hasImage ? thenResult : elseResult;\n        }\n    };\n    let Preview;\n    (function (Preview) {\n        const $ = jQuery;\n        function isConditionalAtRuleConfig(config) {\n            if ((typeof config !== 'object') || (config === null)) {\n                return false;\n            }\n            const configAsRecord = config;\n            return ((typeof configAsRecord['t'] === 'string')\n                && (configAsRecord['t'] === 'conditionalAtRule')\n                && (typeof configAsRecord['identifier'] === 'string'));\n        }\n        function isRuleSetConfig(config) {\n            return ((config !== null)\n                && (Array.isArray(config['selectors']))\n                && (Array.isArray(config['generators'])));\n        }\n        const inactiveSettingMarker = { '_ame_inactive_setting': true };\n        class PreviewSession {\n            constructor(config) {\n                this.settings = {};\n                this.valueReaders = new Set();\n                this.notFound = {};\n                this.variables = {};\n                this.styleBlocks = [];\n                this.stylesheetsToDisable = [];\n                this.stylesheetWasEnabled = {};\n                /**\n                 * Whether this is the first time the preview is being updated.\n                 * This is set to false after preview() is called for the first time.\n                 */\n                this._isBeforeFirstUpdate = true;\n                //Optimization: Create bound getters once instead of every time we need\n                //to create a setting or variable reference.\n                this.settingValueGetter = this.getSettingPreviewValue.bind(this);\n                this.variableValueGetter = (variableName) => {\n                    if (variableName in this.variables) {\n                        return this.variables[variableName].getValue();\n                    }\n                    return null;\n                };\n                //Optionally, disable already generated custom stylesheets while the preview\n                //is active to prevent old settings from interfering with the preview of new settings.\n                if (Array.isArray(config.stylesheetsToDisable)) {\n                    this.stylesheetsToDisable = config.stylesheetsToDisable;\n                }\n                //Variables\n                for (const variableName in config.variables) {\n                    if (!config.variables.hasOwnProperty(variableName)) {\n                        continue;\n                    }\n                    this.variables[variableName] = this.createValueDescriptor(config.variables[variableName], true);\n                }\n                //CSS statement groups\n                for (const conditionConfig of config.statementGroups) {\n                    const statements = this.createCssStatements(conditionConfig.statements);\n                    if (statements.length < 1) {\n                        continue;\n                    }\n                    const condition = this.createValueDescriptor(conditionConfig.expression, true);\n                    const usedSettingIds = this.getSettingIdsUsedBy(condition);\n                    const conditionCallback = () => {\n                        //For performance, conditions that reference settings should\n                        //only be checked when at least one setting is active.\n                        if (usedSettingIds.length > 0) {\n                            if (!usedSettingIds.some((id) => this.isSettingActive(id))) {\n                                return false;\n                            }\n                        }\n                        const isTruthy = condition.getValue();\n                        return !!isTruthy; //Convert to boolean.\n                    };\n                    this.styleBlocks.push(new PreviewStyleBlock(statements, conditionCallback));\n                }\n            }\n            createValueDescriptor(data, allowUnknownVariables = false) {\n                switch (data.t) {\n                    case 'constant':\n                        return new ConstantValue(data.value);\n                    case 'array':\n                        return new ArrayValue(data.items.map((valueData) => this.createValueDescriptor(valueData, allowUnknownVariables)));\n                    case 'setting':\n                        this.registerPreviewableSettingId(data.id);\n                        return new SettingReference(data.id, this.settingValueGetter);\n                    case 'var':\n                        if (!this.variables.hasOwnProperty(data.name) && !allowUnknownVariables) {\n                            throw new Error('Unknown variable: ' + data.name);\n                        }\n                        return new VariableReference(data.name, this.variableValueGetter);\n                    case 'funcCall':\n                        let functionName;\n                        if (data.name in builtinFunctions) {\n                            functionName = data.name;\n                        }\n                        else {\n                            throw new Error('Unknown function: ' + data.name);\n                        }\n                        const func = builtinFunctions[functionName];\n                        //Initialize the function arguments.\n                        let args;\n                        if (Array.isArray(data.args)) {\n                            args = data.args.map(arg => this.createValueDescriptor(arg, allowUnknownVariables));\n                        }\n                        else {\n                            args = {};\n                            for (const argName in data.args) {\n                                if (!data.args.hasOwnProperty(argName)) {\n                                    continue;\n                                }\n                                args[argName] = this.createValueDescriptor(data.args[argName], allowUnknownVariables);\n                            }\n                        }\n                        // @ts-ignore - Can't really statically check this since the values come from the server.\n                        return new FunctionCall(args, func);\n                }\n            }\n            /**\n             * Get the IDs of all settings that are referenced by the given descriptor.\n             *\n             * @param descriptor\n             * @private\n             */\n            getSettingIdsUsedBy(descriptor) {\n                if (descriptor instanceof SettingReference) {\n                    return [descriptor.settingId];\n                }\n                if (descriptor instanceof ArrayValue) {\n                    let result = [];\n                    for (const item of descriptor.getItemDescriptors()) {\n                        result = result.concat(this.getSettingIdsUsedBy(item));\n                    }\n                    return uniqueArrayValues(result);\n                }\n                if (descriptor instanceof FunctionCall) {\n                    let result = [];\n                    const args = descriptor.args;\n                    if (Array.isArray(args)) {\n                        for (const arg of args) {\n                            result = result.concat(this.getSettingIdsUsedBy(arg));\n                        }\n                    }\n                    else {\n                        for (const argName in args) {\n                            if (args.hasOwnProperty(argName)) {\n                                result = result.concat(this.getSettingIdsUsedBy(args[argName]));\n                            }\n                        }\n                    }\n                    return uniqueArrayValues(result);\n                }\n                if (descriptor instanceof VariableReference) {\n                    const varDef = this.getVariableDefinition(descriptor.name);\n                    if (varDef === null) {\n                        return [];\n                    }\n                    return this.getSettingIdsUsedBy(varDef);\n                }\n                return [];\n            }\n            getVariableDefinition(variableName) {\n                if (!this.variables.hasOwnProperty(variableName)) {\n                    return null;\n                }\n                return this.variables[variableName];\n            }\n            createCssStatements(configs) {\n                let results = [];\n                for (const config of configs) {\n                    if (isRuleSetConfig(config)) {\n                        results.push(this.createRuleSetFromConfig(config));\n                    }\n                    else if (isConditionalAtRuleConfig(config)) {\n                        results.push(new ConditionalAtRule(config.identifier, config.condition, (typeof config.nestedStatements === 'undefined')\n                            ? []\n                            : this.createCssStatements(config.nestedStatements)));\n                    }\n                    else {\n                        console.error('Unknown CSS statement type: ', config);\n                    }\n                }\n                return results;\n            }\n            createRuleSetFromConfig(config, parent = null) {\n                const generatorWrappers = this.makeGeneratorWrappers(config.generators);\n                const ruleSet = new CssRuleSet(config.selectors, generatorWrappers, parent);\n                const nestedRuleSets = this.createNestedRuleSets(config.nestedStatements, ruleSet);\n                ruleSet.setNestedRuleSets(nestedRuleSets);\n                return ruleSet;\n            }\n            createNestedRuleSets(configs, parent = null) {\n                let results = [];\n                if (!configs) {\n                    return results;\n                }\n                for (const config of configs) {\n                    if (!isRuleSetConfig(config)) {\n                        throw new Error('A CSS rule set can only contain other rule sets, not other types of statements.');\n                    }\n                    results.push(this.createRuleSetFromConfig(config, parent));\n                }\n                return results;\n            }\n            getPreviewableSettingIDs() {\n                return Object.keys(this.settings);\n            }\n            preview(settingId, value, otherSettingReader) {\n                if (this._isBeforeFirstUpdate) {\n                    this._isBeforeFirstUpdate = false;\n                    this.disableAssociatedStylesheets();\n                }\n                this.valueReaders.add(otherSettingReader);\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    this.settings[settingId] = ko.observable(value);\n                }\n                else {\n                    this.settings[settingId](value);\n                }\n            }\n            dispose() {\n                //Dispose of all style blocks.\n                for (const block of this.styleBlocks) {\n                    block.dispose();\n                }\n                this.reEnableAssociatedStylesheets();\n            }\n            disableAssociatedStylesheets() {\n                for (const stylesheetSelector of this.stylesheetsToDisable) {\n                    const $link = $(stylesheetSelector);\n                    if ($link.length > 0) {\n                        this.stylesheetWasEnabled[stylesheetSelector] = $link.prop('disabled');\n                        $link.prop('disabled', true);\n                    }\n                }\n            }\n            reEnableAssociatedStylesheets() {\n                for (const stylesheetSelector of this.stylesheetsToDisable) {\n                    const $link = $(stylesheetSelector);\n                    if (($link.length > 0) && this.stylesheetWasEnabled.hasOwnProperty(stylesheetSelector)) {\n                        $link.prop('disabled', this.stylesheetWasEnabled[stylesheetSelector]);\n                    }\n                }\n            }\n            isSettingActive(settingId) {\n                if (this.settings.hasOwnProperty(settingId)) {\n                    return this.settings[settingId]() !== inactiveSettingMarker;\n                }\n                return false;\n            }\n            getSettingPreviewValue(settingId) {\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    const value = this.getSettingFromReaders(settingId);\n                    this.settings[settingId] = ko.observable(value).extend({ deferred: true });\n                }\n                const observable = this.settings[settingId];\n                let value = observable();\n                if (value === inactiveSettingMarker) {\n                    value = this.getSettingFromReaders(settingId);\n                    observable(value);\n                }\n                return value;\n            }\n            getSettingFromReaders(settingId) {\n                for (const reader of this.valueReaders) {\n                    const value = reader(settingId, this.notFound);\n                    if (value !== this.notFound) {\n                        return value;\n                    }\n                }\n                throw new Error('Setting not found for preview: ' + settingId);\n            }\n            makeGeneratorWrappers(generatorConfigs) {\n                let generatorWrappers = [];\n                for (const generatorConfig of generatorConfigs) {\n                    const wrapper = this.makeDeclarationGeneratorWrapper(generatorConfig);\n                    if (wrapper !== null) {\n                        generatorWrappers.push(wrapper);\n                    }\n                }\n                return generatorWrappers;\n            }\n            makeDeclarationGeneratorWrapper(config) {\n                const generator = this.createValueDescriptor(config);\n                return new DeclarationGeneratorWrapper(generator, this);\n            }\n            registerPreviewableSettingId(settingId) {\n                if (!this.settings.hasOwnProperty(settingId)) {\n                    this.settings[settingId] = ko.observable(inactiveSettingMarker);\n                }\n            }\n            get isBeforeFirstUpdate() {\n                return this._isBeforeFirstUpdate;\n            }\n        }\n        /**\n         * Preview manager for the style generator.\n         *\n         * This is a thin wrapper around the PreviewSession class. It initializes the session\n         * as needed and destroys it when the preview is cleared. This makes it simpler to manage\n         * active settings, style blocks, and CSS rule-sets: instead of having to carefully\n         * track dependencies and deactivate/reactivate them in the right order whenever the preview\n         * is disabled/enabled, we can just destroy the session and start over.\n         */\n        class StyleGeneratorPreview {\n            constructor(config) {\n                this.config = config;\n                this.currentSession = null;\n            }\n            getOrCreateSession() {\n                if (this.currentSession === null) {\n                    this.currentSession = new PreviewSession(this.config);\n                }\n                return this.currentSession;\n            }\n            getPreviewableSettingIDs() {\n                return this.getOrCreateSession().getPreviewableSettingIDs();\n            }\n            preview(settingId, value, otherSettingReader) {\n                const session = this.getOrCreateSession();\n                const shouldPreviewAll = (this.config.previewAllOnFirstUpdate && session.isBeforeFirstUpdate);\n                session.preview(settingId, value, otherSettingReader);\n                if (shouldPreviewAll) {\n                    //Preview all registered settings the first time the preview is updated.\n                    const notFound = {};\n                    for (const otherId of session.getPreviewableSettingIDs()) {\n                        const otherValue = otherSettingReader(otherId, notFound);\n                        if ((otherId !== settingId) && (otherValue !== notFound)) {\n                            session.preview(otherId, otherValue, otherSettingReader);\n                        }\n                    }\n                }\n            }\n            clearPreview() {\n                if (this.currentSession !== null) {\n                    this.currentSession.dispose();\n                    this.currentSession = null;\n                }\n            }\n        }\n        Preview.StyleGeneratorPreview = StyleGeneratorPreview;\n        class DeclarationGeneratorWrapper {\n            constructor(generator, settingSource) {\n                this.generator = generator;\n                this.settingSource = settingSource;\n                //Introspect the generator and see which settings it uses.\n                //This will be useful to determine if the generator is active.\n                this.usedSettingIds = DeclarationGeneratorWrapper.findReferencedSettingIds(generator, settingSource);\n                this.cssDeclarations = ko.computed({\n                    read: () => this.getDeclarations(),\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n            }\n            /**\n             * Recursively find all settings used by a value descriptor (such as a function call).\n             *\n             * @param {ValueDescriptor} thing\n             * @param variableSource Needed to get variable definitions and not just the final values.\n             */\n            static findReferencedSettingIds(thing, variableSource) {\n                let settingIds = [];\n                if (thing instanceof SettingReference) {\n                    settingIds.push(thing.settingId);\n                }\n                else if (thing instanceof FunctionCall) {\n                    if (Array.isArray(thing.args)) {\n                        for (const arg of thing.args) {\n                            settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(arg, variableSource));\n                        }\n                    }\n                    else {\n                        for (const key in thing.args) {\n                            settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(thing.args[key], variableSource));\n                        }\n                    }\n                }\n                else if (thing instanceof VariableReference) {\n                    const value = variableSource.getVariableDefinition(thing.name);\n                    if (value !== null) {\n                        settingIds = settingIds.concat(DeclarationGeneratorWrapper.findReferencedSettingIds(value, variableSource));\n                    }\n                }\n                return settingIds;\n            }\n            isActive() {\n                //Check if any of the input settings are active.\n                let hasSettingLookups = false;\n                for (const settingId of this.usedSettingIds) {\n                    hasSettingLookups = true;\n                    if (this.settingSource.isSettingActive(settingId)) {\n                        return true;\n                    }\n                }\n                //If there are no input settings, the generator is always active: it just\n                //generates a fixed declaration.\n                return !hasSettingLookups;\n            }\n            getDeclarations() {\n                return this.generator.getValue();\n            }\n            dispose() {\n                this.cssDeclarations.dispose();\n            }\n        }\n        class CssStatement {\n            constructor() {\n                this.cssText = ko.computed({\n                    read: () => this.generateCss(),\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n            }\n            dispose() {\n                //Dispose the CSS text observable.\n                this.cssText.dispose();\n            }\n        }\n        class CssRuleSet extends CssStatement {\n            constructor(selectors, declarationSources, parent = null) {\n                super();\n                this.declarationSources = declarationSources;\n                this.nestedRuleSets = ko.observableArray([]);\n                if (parent === null) {\n                    this.effectiveSelectors = selectors;\n                }\n                else {\n                    this.effectiveSelectors = CssRuleSet.combineSelectors(selectors, parent.effectiveSelectors);\n                }\n                this.selectorText = this.effectiveSelectors.join(', ');\n            }\n            static combineSelectors(selectors, parentSelectors) {\n                const combinedSelectors = [];\n                for (const selector of selectors) {\n                    if (selector === '') {\n                        continue;\n                    }\n                    if (selector.includes('&')) {\n                        //Insert the parent selectors into the current selector at the position of the \"&\".\n                        for (const parentSelector of parentSelectors) {\n                            combinedSelectors.push(selector.replace('&', parentSelector.trim()));\n                        }\n                    }\n                    else {\n                        //Just append the current selector to the parent selectors.\n                        for (const parentSelector of parentSelectors) {\n                            combinedSelectors.push(`${parentSelector} ${selector}`);\n                        }\n                    }\n                }\n                return combinedSelectors;\n            }\n            setNestedRuleSets(ruleSets) {\n                //Dispose the old rule sets that are not part of the new list.\n                for (const oldRuleSet of this.nestedRuleSets()) {\n                    if (ruleSets.indexOf(oldRuleSet) === -1) {\n                        oldRuleSet.dispose();\n                    }\n                }\n                this.nestedRuleSets(ruleSets);\n            }\n            generateCss() {\n                const declarations = this.getDeclarations();\n                const nestedRuleSetParts = [];\n                for (const ruleSet of this.nestedRuleSets()) {\n                    if (ruleSet.isActive()) {\n                        nestedRuleSetParts.push(ruleSet.cssText());\n                    }\n                }\n                let css = '';\n                if (declarations.length > 0) {\n                    css += this.selectorText + ' {\\n\\t' + declarations.join('\\n\\t') + '\\n}\\n';\n                }\n                if (nestedRuleSetParts.length > 0) {\n                    css += nestedRuleSetParts.join('\\n');\n                }\n                return css;\n            }\n            isActive() {\n                for (const source of this.declarationSources) {\n                    if (source.isActive()) {\n                        return true;\n                    }\n                }\n                for (const ruleSet of this.nestedRuleSets()) {\n                    if (ruleSet.isActive()) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            getDeclarations() {\n                const declarations = [];\n                for (const source of this.declarationSources) {\n                    if (source.isActive()) {\n                        declarations.push(...source.cssDeclarations());\n                    }\n                }\n                return declarations;\n            }\n            dispose() {\n                //Dispose declaration sources.\n                for (const source of this.declarationSources) {\n                    source.dispose();\n                }\n                //Dispose nested rule sets.\n                for (const ruleSet of this.nestedRuleSets()) {\n                    ruleSet.dispose();\n                }\n                super.dispose();\n            }\n        }\n        class ConditionalAtRule extends CssStatement {\n            constructor(identifier, condition, nestedStatements) {\n                super();\n                this.identifier = identifier;\n                this.condition = condition;\n                this.nestedStatements = nestedStatements;\n            }\n            generateCss() {\n                const pieces = [];\n                for (const statement of this.nestedStatements) {\n                    const css = statement.cssText();\n                    if (css !== '') {\n                        pieces.push(css);\n                    }\n                }\n                if (pieces.length === 0) {\n                    return '';\n                }\n                return this.getAtRuleText() + ' {\\n\\t' + pieces.join('\\n\\t') + '\\n}';\n            }\n            getAtRuleText() {\n                return '@' + this.identifier + ' ' + this.condition;\n            }\n            isActive() {\n                for (const statement of this.nestedStatements) {\n                    if (statement.isActive()) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            dispose() {\n                //Dispose nested statements.\n                for (const statement of this.nestedStatements) {\n                    statement.dispose();\n                }\n                super.dispose();\n            }\n        }\n        class PreviewStyleBlock {\n            constructor(statements, condition = null) {\n                this.statements = statements;\n                this.condition = condition;\n                this.$styleElement = null;\n                this.cssText = ko.computed({\n                    read: () => {\n                        if ((condition !== null) && !condition()) {\n                            return '';\n                        }\n                        let pieces = [];\n                        for (const statement of this.statements) {\n                            if (statement.isActive()) {\n                                const css = statement.cssText();\n                                if (css !== '') {\n                                    pieces.push(css);\n                                }\n                            }\n                        }\n                        if (pieces.length === 0) {\n                            return '';\n                        }\n                        return pieces.join('\\n');\n                    },\n                    deferEvaluation: true,\n                }).extend({ deferred: true });\n                this.updateStyleElement(this.cssText());\n                this.cssChangeSubscription = this.cssText.subscribe((cssText) => {\n                    this.updateStyleElement(cssText);\n                });\n            }\n            updateStyleElement(cssText) {\n                if (cssText === '') {\n                    if (this.$styleElement) {\n                        this.$styleElement.remove();\n                        this.$styleElement = null;\n                    }\n                    return;\n                }\n                if (!this.$styleElement) {\n                    this.$styleElement = $('<style></style>').appendTo('head');\n                }\n                this.$styleElement.text(cssText);\n            }\n            clear() {\n                if (this.$styleElement) {\n                    this.$styleElement.remove();\n                    this.$styleElement = null;\n                }\n            }\n            dispose() {\n                //Stop listening for CSS changes.\n                this.cssChangeSubscription.dispose();\n                this.cssText.dispose();\n                //Dispose rule sets.\n                for (const ruleset of this.statements) {\n                    ruleset.dispose();\n                }\n                //Remove the style element.\n                this.clear();\n            }\n        }\n    })(Preview = AmeStyleGenerator.Preview || (AmeStyleGenerator.Preview = {}));\n})(AmeStyleGenerator || (AmeStyleGenerator = {}));\n//# sourceMappingURL=style-generator.js.map"],"names":[],"sourceRoot":""}